{
  "version": 3,
  "sources": ["../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/functions/sign-data/sign-data.ts", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/runtime/base64url.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/runtime/digest.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/lib/buffer_utils.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/runtime/decrypt.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/util/errors.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/runtime/random.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/runtime/is_key_object.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/runtime/timing_safe_equal.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/runtime/cbc_tag.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/runtime/webcrypto.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/lib/crypto_key.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/lib/invalid_key_input.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/runtime/ciphers.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/runtime/is_key_like.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/runtime/zlib.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/lib/is_disjoint.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/lib/is_object.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/runtime/aeskw.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/runtime/ecdhes.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/runtime/get_named_curve.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/runtime/pbes2kw.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/runtime/rsaes.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/runtime/check_modulus_length.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/runtime/asn1.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/runtime/jwk_to_key.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/runtime/asn1_sequence_encoder.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/runtime/flags.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/lib/check_key_type.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/runtime/encrypt.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/lib/validate_crit.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/lib/validate_algorithms.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/runtime/key_to_jwk.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/jwe/flattened/encrypt.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/runtime/verify.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/runtime/dsa_digest.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/runtime/node_key.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/runtime/sign.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/runtime/hmac_digest.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/runtime/get_sign_verify_key.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/jws/flattened/verify.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/jws/compact/verify.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/lib/epoch.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/lib/secs.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/lib/jwt_claims_set.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/jwt/verify.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/jws/flattened/sign.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/jws/compact/sign.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/jwt/produce.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/jwt/sign.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/runtime/fetch_jwks.js", "../../../../../../Users/fcolaci/source/github/felixcolaci/cic-account-linking/node_modules/jose/dist/node/esm/runtime/generate.js"],
  "sourceRoot": "/var/folders/vn/vnbnq3z15z76sgrlhndkswlh0000gq/T/tmp-47097-UzWRYUneUD0K",
  "sourcesContent": ["import { Handler } from \"@netlify/functions\";\nimport { jwtVerify, SignJWT } from \"jose\";\n\nconst { TOKEN_SIGNING } = process.env;\n\nconst corsHeaders = {\n  \"Access-Control-Allow-Origin\": \"*\",\n  \"Access-Control-Allow-Headers\": \"Content-Type\",\n  \"Access-Control-Allow-Methods\": \"GET, POST, PUT, DELETE\",\n};\n\nconst handleCors = (event) => {\n  if (event.httpMethod == \"OPTIONS\") {\n    // To enable CORS\n    return {\n      statusCode: 200, // <-- Important!\n      headers: corsHeaders,\n      body: \"Options Callback\",\n    };\n  }\n};\n\nconst handleError = (message: string, status = 400) => {\n  return {\n    statusCode: status,\n    body: JSON.stringify({\n      message,\n      status,\n    }),\n    headers: {\n      \"content-type\": \"application/json\",\n      ...corsHeaders,\n    },\n  };\n};\n\nexport const handler: Handler = async (event, context) => {\n  const corsResponse = handleCors(event);\n  if (corsResponse) {\n    return corsResponse;\n  }\n\n  // @ts-ignore\n  const { state, link_with, sessionToken, provider, user_id, action } = JSON.parse(event.body);\n  if (!state || !sessionToken) {\n    return handleError(\"provide state, link_with and sessionToken!\");\n  }\n\n  try {\n    const { payload } = await jwtVerify(sessionToken, Buffer.from(TOKEN_SIGNING || \"\"), {\n      algorithms: [\"HS256\"],\n    });\n\n    const token = await new SignJWT({\n      state,\n      link_with,\n      provider,\n      user_id,\n      action,\n    })\n      .setSubject(payload.sub || \"\")\n      .setProtectedHeader({ alg: \"HS256\", typ: \"JWT\" })\n      .setIssuedAt()\n      .setIssuer(\"https://cic-account-linking.netflify.app\")\n      .setExpirationTime(\"60s\")\n      .sign(Buffer.from(TOKEN_SIGNING || \"\"));\n\n    return {\n      statusCode: 200,\n      body: JSON.stringify({ token }),\n      headers: {\n        \"content-type\": \"application/json\",\n        ...corsHeaders,\n      },\n    };\n  } catch (error) {\n    return handleError(\"the provided token is invalid\", 401);\n  }\n};\n", "import { Buffer } from 'buffer';\nimport { decoder } from '../lib/buffer_utils.js';\nlet encode;\nfunction normalize(input) {\n    let encoded = input;\n    if (encoded instanceof Uint8Array) {\n        encoded = decoder.decode(encoded);\n    }\n    return encoded;\n}\nif (Buffer.isEncoding('base64url')) {\n    encode = (input) => Buffer.from(input).toString('base64url');\n}\nelse {\n    encode = (input) => Buffer.from(input).toString('base64').replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_');\n}\nexport const decodeBase64 = (input) => Buffer.from(input, 'base64');\nexport const encodeBase64 = (input) => Buffer.from(input).toString('base64');\nexport { encode };\nexport const decode = (input) => Buffer.from(normalize(input), 'base64');\n", "import { createHash } from 'crypto';\nconst digest = (algorithm, data) => createHash(algorithm).update(data).digest();\nexport default digest;\n", "import digest from '../runtime/digest.js';\nexport const encoder = new TextEncoder();\nexport const decoder = new TextDecoder();\nconst MAX_INT32 = 2 ** 32;\nexport function concat(...buffers) {\n    const size = buffers.reduce((acc, { length }) => acc + length, 0);\n    const buf = new Uint8Array(size);\n    let i = 0;\n    buffers.forEach((buffer) => {\n        buf.set(buffer, i);\n        i += buffer.length;\n    });\n    return buf;\n}\nexport function p2s(alg, p2sInput) {\n    return concat(encoder.encode(alg), new Uint8Array([0]), p2sInput);\n}\nfunction writeUInt32BE(buf, value, offset) {\n    if (value < 0 || value >= MAX_INT32) {\n        throw new RangeError(`value must be >= 0 and <= ${MAX_INT32 - 1}. Received ${value}`);\n    }\n    buf.set([value >>> 24, value >>> 16, value >>> 8, value & 0xff], offset);\n}\nexport function uint64be(value) {\n    const high = Math.floor(value / MAX_INT32);\n    const low = value % MAX_INT32;\n    const buf = new Uint8Array(8);\n    writeUInt32BE(buf, high, 0);\n    writeUInt32BE(buf, low, 4);\n    return buf;\n}\nexport function uint32be(value) {\n    const buf = new Uint8Array(4);\n    writeUInt32BE(buf, value);\n    return buf;\n}\nexport function lengthAndInput(input) {\n    return concat(uint32be(input.length), input);\n}\nexport async function concatKdf(secret, bits, value) {\n    const iterations = Math.ceil((bits >> 3) / 32);\n    const res = new Uint8Array(iterations * 32);\n    for (let iter = 0; iter < iterations; iter++) {\n        const buf = new Uint8Array(4 + secret.length + value.length);\n        buf.set(uint32be(iter + 1));\n        buf.set(secret, 4);\n        buf.set(value, 4 + secret.length);\n        res.set(await digest('sha256', buf), iter * 32);\n    }\n    return res.slice(0, bits >> 3);\n}\n", "import { createDecipheriv, KeyObject } from 'crypto';\nimport checkIvLength from '../lib/check_iv_length.js';\nimport checkCekLength from './check_cek_length.js';\nimport { concat } from '../lib/buffer_utils.js';\nimport { JOSENotSupported, JWEDecryptionFailed } from '../util/errors.js';\nimport timingSafeEqual from './timing_safe_equal.js';\nimport cbcTag from './cbc_tag.js';\nimport { isCryptoKey } from './webcrypto.js';\nimport { checkEncCryptoKey } from '../lib/crypto_key.js';\nimport isKeyObject from './is_key_object.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport supported from './ciphers.js';\nimport { types } from './is_key_like.js';\nfunction cbcDecrypt(enc, cek, ciphertext, iv, tag, aad) {\n    const keySize = parseInt(enc.slice(1, 4), 10);\n    if (isKeyObject(cek)) {\n        cek = cek.export();\n    }\n    const encKey = cek.subarray(keySize >> 3);\n    const macKey = cek.subarray(0, keySize >> 3);\n    const macSize = parseInt(enc.slice(-3), 10);\n    const algorithm = `aes-${keySize}-cbc`;\n    if (!supported(algorithm)) {\n        throw new JOSENotSupported(`alg ${enc} is not supported by your javascript runtime`);\n    }\n    const expectedTag = cbcTag(aad, iv, ciphertext, macSize, macKey, keySize);\n    let macCheckPassed;\n    try {\n        macCheckPassed = timingSafeEqual(tag, expectedTag);\n    }\n    catch {\n    }\n    if (!macCheckPassed) {\n        throw new JWEDecryptionFailed();\n    }\n    let plaintext;\n    try {\n        const decipher = createDecipheriv(algorithm, encKey, iv);\n        plaintext = concat(decipher.update(ciphertext), decipher.final());\n    }\n    catch {\n    }\n    if (!plaintext) {\n        throw new JWEDecryptionFailed();\n    }\n    return plaintext;\n}\nfunction gcmDecrypt(enc, cek, ciphertext, iv, tag, aad) {\n    const keySize = parseInt(enc.slice(1, 4), 10);\n    const algorithm = `aes-${keySize}-gcm`;\n    if (!supported(algorithm)) {\n        throw new JOSENotSupported(`alg ${enc} is not supported by your javascript runtime`);\n    }\n    try {\n        const decipher = createDecipheriv(algorithm, cek, iv, { authTagLength: 16 });\n        decipher.setAuthTag(tag);\n        if (aad.byteLength) {\n            decipher.setAAD(aad, { plaintextLength: ciphertext.length });\n        }\n        const plaintext = decipher.update(ciphertext);\n        decipher.final();\n        return plaintext;\n    }\n    catch {\n        throw new JWEDecryptionFailed();\n    }\n}\nconst decrypt = (enc, cek, ciphertext, iv, tag, aad) => {\n    let key;\n    if (isCryptoKey(cek)) {\n        checkEncCryptoKey(cek, enc, 'decrypt');\n        key = KeyObject.from(cek);\n    }\n    else if (cek instanceof Uint8Array || isKeyObject(cek)) {\n        key = cek;\n    }\n    else {\n        throw new TypeError(invalidKeyInput(cek, ...types, 'Uint8Array'));\n    }\n    checkCekLength(enc, key);\n    checkIvLength(enc, iv);\n    switch (enc) {\n        case 'A128CBC-HS256':\n        case 'A192CBC-HS384':\n        case 'A256CBC-HS512':\n            return cbcDecrypt(enc, key, ciphertext, iv, tag, aad);\n        case 'A128GCM':\n        case 'A192GCM':\n        case 'A256GCM':\n            return gcmDecrypt(enc, key, ciphertext, iv, tag, aad);\n        default:\n            throw new JOSENotSupported('Unsupported JWE Content Encryption Algorithm');\n    }\n};\nexport default decrypt;\n", "export class JOSEError extends Error {\n    static get code() {\n        return 'ERR_JOSE_GENERIC';\n    }\n    constructor(message) {\n        var _a;\n        super(message);\n        this.code = 'ERR_JOSE_GENERIC';\n        this.name = this.constructor.name;\n        (_a = Error.captureStackTrace) === null || _a === void 0 ? void 0 : _a.call(Error, this, this.constructor);\n    }\n}\nexport class JWTClaimValidationFailed extends JOSEError {\n    static get code() {\n        return 'ERR_JWT_CLAIM_VALIDATION_FAILED';\n    }\n    constructor(message, claim = 'unspecified', reason = 'unspecified') {\n        super(message);\n        this.code = 'ERR_JWT_CLAIM_VALIDATION_FAILED';\n        this.claim = claim;\n        this.reason = reason;\n    }\n}\nexport class JWTExpired extends JOSEError {\n    static get code() {\n        return 'ERR_JWT_EXPIRED';\n    }\n    constructor(message, claim = 'unspecified', reason = 'unspecified') {\n        super(message);\n        this.code = 'ERR_JWT_EXPIRED';\n        this.claim = claim;\n        this.reason = reason;\n    }\n}\nexport class JOSEAlgNotAllowed extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JOSE_ALG_NOT_ALLOWED';\n    }\n    static get code() {\n        return 'ERR_JOSE_ALG_NOT_ALLOWED';\n    }\n}\nexport class JOSENotSupported extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JOSE_NOT_SUPPORTED';\n    }\n    static get code() {\n        return 'ERR_JOSE_NOT_SUPPORTED';\n    }\n}\nexport class JWEDecryptionFailed extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWE_DECRYPTION_FAILED';\n        this.message = 'decryption operation failed';\n    }\n    static get code() {\n        return 'ERR_JWE_DECRYPTION_FAILED';\n    }\n}\nexport class JWEInvalid extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWE_INVALID';\n    }\n    static get code() {\n        return 'ERR_JWE_INVALID';\n    }\n}\nexport class JWSInvalid extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWS_INVALID';\n    }\n    static get code() {\n        return 'ERR_JWS_INVALID';\n    }\n}\nexport class JWTInvalid extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWT_INVALID';\n    }\n    static get code() {\n        return 'ERR_JWT_INVALID';\n    }\n}\nexport class JWKInvalid extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWK_INVALID';\n    }\n    static get code() {\n        return 'ERR_JWK_INVALID';\n    }\n}\nexport class JWKSInvalid extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWKS_INVALID';\n    }\n    static get code() {\n        return 'ERR_JWKS_INVALID';\n    }\n}\nexport class JWKSNoMatchingKey extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWKS_NO_MATCHING_KEY';\n        this.message = 'no applicable key found in the JSON Web Key Set';\n    }\n    static get code() {\n        return 'ERR_JWKS_NO_MATCHING_KEY';\n    }\n}\nexport class JWKSMultipleMatchingKeys extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';\n        this.message = 'multiple matching keys found in the JSON Web Key Set';\n    }\n    static get code() {\n        return 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';\n    }\n}\nSymbol.asyncIterator;\nexport class JWKSTimeout extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWKS_TIMEOUT';\n        this.message = 'request timed out';\n    }\n    static get code() {\n        return 'ERR_JWKS_TIMEOUT';\n    }\n}\nexport class JWSSignatureVerificationFailed extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';\n        this.message = 'signature verification failed';\n    }\n    static get code() {\n        return 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';\n    }\n}\n", "export { randomFillSync as default } from 'crypto';\n", "import { KeyObject } from 'crypto';\nimport * as util from 'util';\nexport default util.types.isKeyObject\n    ? (obj) => util.types.isKeyObject(obj)\n    : (obj) => obj != null && obj instanceof KeyObject;\n", "import { timingSafeEqual as impl } from 'crypto';\nconst timingSafeEqual = impl;\nexport default timingSafeEqual;\n", "import { createHmac } from 'crypto';\nimport { concat, uint64be } from '../lib/buffer_utils.js';\nexport default function cbcTag(aad, iv, ciphertext, macSize, macKey, keySize) {\n    const macData = concat(aad, iv, ciphertext, uint64be(aad.length << 3));\n    const hmac = createHmac(`sha${macSize}`, macKey);\n    hmac.update(macData);\n    return hmac.digest().slice(0, keySize >> 3);\n}\n", "import * as crypto from 'crypto';\nimport * as util from 'util';\nconst webcrypto = crypto.webcrypto;\nexport default webcrypto;\nexport const isCryptoKey = util.types.isCryptoKey\n    ? (key) => util.types.isCryptoKey(key)\n    :\n        (key) => false;\n", "function unusable(name, prop = 'algorithm.name') {\n    return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);\n}\nfunction isAlgorithm(algorithm, name) {\n    return algorithm.name === name;\n}\nfunction getHashLength(hash) {\n    return parseInt(hash.name.slice(4), 10);\n}\nfunction getNamedCurve(alg) {\n    switch (alg) {\n        case 'ES256':\n            return 'P-256';\n        case 'ES384':\n            return 'P-384';\n        case 'ES512':\n            return 'P-521';\n        default:\n            throw new Error('unreachable');\n    }\n}\nfunction checkUsage(key, usages) {\n    if (usages.length && !usages.some((expected) => key.usages.includes(expected))) {\n        let msg = 'CryptoKey does not support this operation, its usages must include ';\n        if (usages.length > 2) {\n            const last = usages.pop();\n            msg += `one of ${usages.join(', ')}, or ${last}.`;\n        }\n        else if (usages.length === 2) {\n            msg += `one of ${usages[0]} or ${usages[1]}.`;\n        }\n        else {\n            msg += `${usages[0]}.`;\n        }\n        throw new TypeError(msg);\n    }\n}\nexport function checkSigCryptoKey(key, alg, ...usages) {\n    switch (alg) {\n        case 'HS256':\n        case 'HS384':\n        case 'HS512': {\n            if (!isAlgorithm(key.algorithm, 'HMAC'))\n                throw unusable('HMAC');\n            const expected = parseInt(alg.slice(2), 10);\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        case 'RS256':\n        case 'RS384':\n        case 'RS512': {\n            if (!isAlgorithm(key.algorithm, 'RSASSA-PKCS1-v1_5'))\n                throw unusable('RSASSA-PKCS1-v1_5');\n            const expected = parseInt(alg.slice(2), 10);\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        case 'PS256':\n        case 'PS384':\n        case 'PS512': {\n            if (!isAlgorithm(key.algorithm, 'RSA-PSS'))\n                throw unusable('RSA-PSS');\n            const expected = parseInt(alg.slice(2), 10);\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        case 'EdDSA': {\n            if (key.algorithm.name !== 'Ed25519' && key.algorithm.name !== 'Ed448') {\n                throw unusable('Ed25519 or Ed448');\n            }\n            break;\n        }\n        case 'ES256':\n        case 'ES384':\n        case 'ES512': {\n            if (!isAlgorithm(key.algorithm, 'ECDSA'))\n                throw unusable('ECDSA');\n            const expected = getNamedCurve(alg);\n            const actual = key.algorithm.namedCurve;\n            if (actual !== expected)\n                throw unusable(expected, 'algorithm.namedCurve');\n            break;\n        }\n        default:\n            throw new TypeError('CryptoKey does not support this operation');\n    }\n    checkUsage(key, usages);\n}\nexport function checkEncCryptoKey(key, alg, ...usages) {\n    switch (alg) {\n        case 'A128GCM':\n        case 'A192GCM':\n        case 'A256GCM': {\n            if (!isAlgorithm(key.algorithm, 'AES-GCM'))\n                throw unusable('AES-GCM');\n            const expected = parseInt(alg.slice(1, 4), 10);\n            const actual = key.algorithm.length;\n            if (actual !== expected)\n                throw unusable(expected, 'algorithm.length');\n            break;\n        }\n        case 'A128KW':\n        case 'A192KW':\n        case 'A256KW': {\n            if (!isAlgorithm(key.algorithm, 'AES-KW'))\n                throw unusable('AES-KW');\n            const expected = parseInt(alg.slice(1, 4), 10);\n            const actual = key.algorithm.length;\n            if (actual !== expected)\n                throw unusable(expected, 'algorithm.length');\n            break;\n        }\n        case 'ECDH': {\n            switch (key.algorithm.name) {\n                case 'ECDH':\n                case 'X25519':\n                case 'X448':\n                    break;\n                default:\n                    throw unusable('ECDH, X25519, or X448');\n            }\n            break;\n        }\n        case 'PBES2-HS256+A128KW':\n        case 'PBES2-HS384+A192KW':\n        case 'PBES2-HS512+A256KW':\n            if (!isAlgorithm(key.algorithm, 'PBKDF2'))\n                throw unusable('PBKDF2');\n            break;\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512': {\n            if (!isAlgorithm(key.algorithm, 'RSA-OAEP'))\n                throw unusable('RSA-OAEP');\n            const expected = parseInt(alg.slice(9), 10) || 1;\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        default:\n            throw new TypeError('CryptoKey does not support this operation');\n    }\n    checkUsage(key, usages);\n}\n", "function message(msg, actual, ...types) {\n    if (types.length > 2) {\n        const last = types.pop();\n        msg += `one of type ${types.join(', ')}, or ${last}.`;\n    }\n    else if (types.length === 2) {\n        msg += `one of type ${types[0]} or ${types[1]}.`;\n    }\n    else {\n        msg += `of type ${types[0]}.`;\n    }\n    if (actual == null) {\n        msg += ` Received ${actual}`;\n    }\n    else if (typeof actual === 'function' && actual.name) {\n        msg += ` Received function ${actual.name}`;\n    }\n    else if (typeof actual === 'object' && actual != null) {\n        if (actual.constructor && actual.constructor.name) {\n            msg += ` Received an instance of ${actual.constructor.name}`;\n        }\n    }\n    return msg;\n}\nexport default (actual, ...types) => {\n    return message('Key must be ', actual, ...types);\n};\nexport function withAlg(alg, actual, ...types) {\n    return message(`Key for the ${alg} algorithm must be `, actual, ...types);\n}\n", "import { getCiphers } from 'crypto';\nlet ciphers;\nexport default (algorithm) => {\n    ciphers || (ciphers = new Set(getCiphers()));\n    return ciphers.has(algorithm);\n};\n", "import webcrypto, { isCryptoKey } from './webcrypto.js';\nimport isKeyObject from './is_key_object.js';\nexport default (key) => isKeyObject(key) || isCryptoKey(key);\nconst types = ['KeyObject'];\nif (globalThis.CryptoKey || (webcrypto === null || webcrypto === void 0 ? void 0 : webcrypto.CryptoKey)) {\n    types.push('CryptoKey');\n}\nexport { types };\n", "import { promisify } from 'util';\nimport { inflateRaw as inflateRawCb, deflateRaw as deflateRawCb } from 'zlib';\nconst inflateRaw = promisify(inflateRawCb);\nconst deflateRaw = promisify(deflateRawCb);\nexport const inflate = (input) => inflateRaw(input);\nexport const deflate = (input) => deflateRaw(input);\n", "const isDisjoint = (...headers) => {\n    const sources = headers.filter(Boolean);\n    if (sources.length === 0 || sources.length === 1) {\n        return true;\n    }\n    let acc;\n    for (const header of sources) {\n        const parameters = Object.keys(header);\n        if (!acc || acc.size === 0) {\n            acc = new Set(parameters);\n            continue;\n        }\n        for (const parameter of parameters) {\n            if (acc.has(parameter)) {\n                return false;\n            }\n            acc.add(parameter);\n        }\n    }\n    return true;\n};\nexport default isDisjoint;\n", "function isObjectLike(value) {\n    return typeof value === 'object' && value !== null;\n}\nexport default function isObject(input) {\n    if (!isObjectLike(input) || Object.prototype.toString.call(input) !== '[object Object]') {\n        return false;\n    }\n    if (Object.getPrototypeOf(input) === null) {\n        return true;\n    }\n    let proto = input;\n    while (Object.getPrototypeOf(proto) !== null) {\n        proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(input) === proto;\n}\n", "import { Buffer } from 'buffer';\nimport { KeyObject, createDecipheriv, createCipheriv, createSecretKey } from 'crypto';\nimport { JOSENotSupported } from '../util/errors.js';\nimport { concat } from '../lib/buffer_utils.js';\nimport { isCryptoKey } from './webcrypto.js';\nimport { checkEncCryptoKey } from '../lib/crypto_key.js';\nimport isKeyObject from './is_key_object.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport supported from './ciphers.js';\nimport { types } from './is_key_like.js';\nfunction checkKeySize(key, alg) {\n    if (key.symmetricKeySize << 3 !== parseInt(alg.slice(1, 4), 10)) {\n        throw new TypeError(`Invalid key size for alg: ${alg}`);\n    }\n}\nfunction ensureKeyObject(key, alg, usage) {\n    if (isKeyObject(key)) {\n        return key;\n    }\n    if (key instanceof Uint8Array) {\n        return createSecretKey(key);\n    }\n    if (isCryptoKey(key)) {\n        checkEncCryptoKey(key, alg, usage);\n        return KeyObject.from(key);\n    }\n    throw new TypeError(invalidKeyInput(key, ...types, 'Uint8Array'));\n}\nexport const wrap = (alg, key, cek) => {\n    const size = parseInt(alg.slice(1, 4), 10);\n    const algorithm = `aes${size}-wrap`;\n    if (!supported(algorithm)) {\n        throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);\n    }\n    const keyObject = ensureKeyObject(key, alg, 'wrapKey');\n    checkKeySize(keyObject, alg);\n    const cipher = createCipheriv(algorithm, keyObject, Buffer.alloc(8, 0xa6));\n    return concat(cipher.update(cek), cipher.final());\n};\nexport const unwrap = (alg, key, encryptedKey) => {\n    const size = parseInt(alg.slice(1, 4), 10);\n    const algorithm = `aes${size}-wrap`;\n    if (!supported(algorithm)) {\n        throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);\n    }\n    const keyObject = ensureKeyObject(key, alg, 'unwrapKey');\n    checkKeySize(keyObject, alg);\n    const cipher = createDecipheriv(algorithm, keyObject, Buffer.alloc(8, 0xa6));\n    return concat(cipher.update(encryptedKey), cipher.final());\n};\n", "import { diffieHellman, generateKeyPair as generateKeyPairCb, KeyObject } from 'crypto';\nimport { promisify } from 'util';\nimport getNamedCurve from './get_named_curve.js';\nimport { encoder, concat, uint32be, lengthAndInput, concatKdf } from '../lib/buffer_utils.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport { isCryptoKey } from './webcrypto.js';\nimport { checkEncCryptoKey } from '../lib/crypto_key.js';\nimport isKeyObject from './is_key_object.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport { types } from './is_key_like.js';\nconst generateKeyPair = promisify(generateKeyPairCb);\nexport async function deriveKey(publicKee, privateKee, algorithm, keyLength, apu = new Uint8Array(0), apv = new Uint8Array(0)) {\n    let publicKey;\n    if (isCryptoKey(publicKee)) {\n        checkEncCryptoKey(publicKee, 'ECDH');\n        publicKey = KeyObject.from(publicKee);\n    }\n    else if (isKeyObject(publicKee)) {\n        publicKey = publicKee;\n    }\n    else {\n        throw new TypeError(invalidKeyInput(publicKee, ...types));\n    }\n    let privateKey;\n    if (isCryptoKey(privateKee)) {\n        checkEncCryptoKey(privateKee, 'ECDH', 'deriveBits');\n        privateKey = KeyObject.from(privateKee);\n    }\n    else if (isKeyObject(privateKee)) {\n        privateKey = privateKee;\n    }\n    else {\n        throw new TypeError(invalidKeyInput(privateKee, ...types));\n    }\n    const value = concat(lengthAndInput(encoder.encode(algorithm)), lengthAndInput(apu), lengthAndInput(apv), uint32be(keyLength));\n    const sharedSecret = diffieHellman({ privateKey, publicKey });\n    return concatKdf(sharedSecret, keyLength, value);\n}\nexport async function generateEpk(kee) {\n    let key;\n    if (isCryptoKey(kee)) {\n        key = KeyObject.from(kee);\n    }\n    else if (isKeyObject(kee)) {\n        key = kee;\n    }\n    else {\n        throw new TypeError(invalidKeyInput(kee, ...types));\n    }\n    switch (key.asymmetricKeyType) {\n        case 'x25519':\n            return generateKeyPair('x25519');\n        case 'x448': {\n            return generateKeyPair('x448');\n        }\n        case 'ec': {\n            const namedCurve = getNamedCurve(key);\n            return generateKeyPair('ec', { namedCurve });\n        }\n        default:\n            throw new JOSENotSupported('Invalid or unsupported EPK');\n    }\n}\nexport const ecdhAllowed = (key) => ['P-256', 'P-384', 'P-521', 'X25519', 'X448'].includes(getNamedCurve(key));\n", "import { Buffer } from 'buffer';\nimport { createPublicKey, KeyObject } from 'crypto';\nimport { JOSENotSupported } from '../util/errors.js';\nimport { isCryptoKey } from './webcrypto.js';\nimport isKeyObject from './is_key_object.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport { types } from './is_key_like.js';\nconst p256 = Buffer.from([42, 134, 72, 206, 61, 3, 1, 7]);\nconst p384 = Buffer.from([43, 129, 4, 0, 34]);\nconst p521 = Buffer.from([43, 129, 4, 0, 35]);\nconst secp256k1 = Buffer.from([43, 129, 4, 0, 10]);\nexport const weakMap = new WeakMap();\nconst namedCurveToJOSE = (namedCurve) => {\n    switch (namedCurve) {\n        case 'prime256v1':\n            return 'P-256';\n        case 'secp384r1':\n            return 'P-384';\n        case 'secp521r1':\n            return 'P-521';\n        case 'secp256k1':\n            return 'secp256k1';\n        default:\n            throw new JOSENotSupported('Unsupported key curve for this operation');\n    }\n};\nconst getNamedCurve = (kee, raw) => {\n    var _a;\n    let key;\n    if (isCryptoKey(kee)) {\n        key = KeyObject.from(kee);\n    }\n    else if (isKeyObject(kee)) {\n        key = kee;\n    }\n    else {\n        throw new TypeError(invalidKeyInput(kee, ...types));\n    }\n    if (key.type === 'secret') {\n        throw new TypeError('only \"private\" or \"public\" type keys can be used for this operation');\n    }\n    switch (key.asymmetricKeyType) {\n        case 'ed25519':\n        case 'ed448':\n            return `Ed${key.asymmetricKeyType.slice(2)}`;\n        case 'x25519':\n        case 'x448':\n            return `X${key.asymmetricKeyType.slice(1)}`;\n        case 'ec': {\n            if (weakMap.has(key)) {\n                return weakMap.get(key);\n            }\n            let namedCurve = (_a = key.asymmetricKeyDetails) === null || _a === void 0 ? void 0 : _a.namedCurve;\n            if (!namedCurve && key.type === 'private') {\n                namedCurve = getNamedCurve(createPublicKey(key), true);\n            }\n            else if (!namedCurve) {\n                const buf = key.export({ format: 'der', type: 'spki' });\n                const i = buf[1] < 128 ? 14 : 15;\n                const len = buf[i];\n                const curveOid = buf.slice(i + 1, i + 1 + len);\n                if (curveOid.equals(p256)) {\n                    namedCurve = 'prime256v1';\n                }\n                else if (curveOid.equals(p384)) {\n                    namedCurve = 'secp384r1';\n                }\n                else if (curveOid.equals(p521)) {\n                    namedCurve = 'secp521r1';\n                }\n                else if (curveOid.equals(secp256k1)) {\n                    namedCurve = 'secp256k1';\n                }\n                else {\n                    throw new JOSENotSupported('Unsupported key curve for this operation');\n                }\n            }\n            if (raw)\n                return namedCurve;\n            const curve = namedCurveToJOSE(namedCurve);\n            weakMap.set(key, curve);\n            return curve;\n        }\n        default:\n            throw new TypeError('Invalid asymmetric key type for this operation');\n    }\n};\nexport function setCurve(keyObject, curve) {\n    weakMap.set(keyObject, curve);\n}\nexport default getNamedCurve;\n", "import { promisify } from 'util';\nimport { KeyObject, pbkdf2 as pbkdf2cb } from 'crypto';\nimport random from './random.js';\nimport { p2s as concatSalt } from '../lib/buffer_utils.js';\nimport { encode as base64url } from './base64url.js';\nimport { wrap, unwrap } from './aeskw.js';\nimport checkP2s from '../lib/check_p2s.js';\nimport { isCryptoKey } from './webcrypto.js';\nimport { checkEncCryptoKey } from '../lib/crypto_key.js';\nimport isKeyObject from './is_key_object.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport { types } from './is_key_like.js';\nconst pbkdf2 = promisify(pbkdf2cb);\nfunction getPassword(key, alg) {\n    if (isKeyObject(key)) {\n        return key.export();\n    }\n    if (key instanceof Uint8Array) {\n        return key;\n    }\n    if (isCryptoKey(key)) {\n        checkEncCryptoKey(key, alg, 'deriveBits', 'deriveKey');\n        return KeyObject.from(key).export();\n    }\n    throw new TypeError(invalidKeyInput(key, ...types, 'Uint8Array'));\n}\nexport const encrypt = async (alg, key, cek, p2c = 2048, p2s = random(new Uint8Array(16))) => {\n    checkP2s(p2s);\n    const salt = concatSalt(alg, p2s);\n    const keylen = parseInt(alg.slice(13, 16), 10) >> 3;\n    const password = getPassword(key, alg);\n    const derivedKey = await pbkdf2(password, salt, p2c, keylen, `sha${alg.slice(8, 11)}`);\n    const encryptedKey = await wrap(alg.slice(-6), derivedKey, cek);\n    return { encryptedKey, p2c, p2s: base64url(p2s) };\n};\nexport const decrypt = async (alg, key, encryptedKey, p2c, p2s) => {\n    checkP2s(p2s);\n    const salt = concatSalt(alg, p2s);\n    const keylen = parseInt(alg.slice(13, 16), 10) >> 3;\n    const password = getPassword(key, alg);\n    const derivedKey = await pbkdf2(password, salt, p2c, keylen, `sha${alg.slice(8, 11)}`);\n    return unwrap(alg.slice(-6), derivedKey, encryptedKey);\n};\n", "import { KeyObject, publicEncrypt, constants, privateDecrypt } from 'crypto';\nimport checkModulusLength from './check_modulus_length.js';\nimport { isCryptoKey } from './webcrypto.js';\nimport { checkEncCryptoKey } from '../lib/crypto_key.js';\nimport isKeyObject from './is_key_object.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport { types } from './is_key_like.js';\nconst checkKey = (key, alg) => {\n    if (key.asymmetricKeyType !== 'rsa') {\n        throw new TypeError('Invalid key for this operation, its asymmetricKeyType must be rsa');\n    }\n    checkModulusLength(key, alg);\n};\nconst resolvePadding = (alg) => {\n    switch (alg) {\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512':\n            return constants.RSA_PKCS1_OAEP_PADDING;\n        case 'RSA1_5':\n            return constants.RSA_PKCS1_PADDING;\n        default:\n            return undefined;\n    }\n};\nconst resolveOaepHash = (alg) => {\n    switch (alg) {\n        case 'RSA-OAEP':\n            return 'sha1';\n        case 'RSA-OAEP-256':\n            return 'sha256';\n        case 'RSA-OAEP-384':\n            return 'sha384';\n        case 'RSA-OAEP-512':\n            return 'sha512';\n        default:\n            return undefined;\n    }\n};\nfunction ensureKeyObject(key, alg, ...usages) {\n    if (isKeyObject(key)) {\n        return key;\n    }\n    if (isCryptoKey(key)) {\n        checkEncCryptoKey(key, alg, ...usages);\n        return KeyObject.from(key);\n    }\n    throw new TypeError(invalidKeyInput(key, ...types));\n}\nexport const encrypt = (alg, key, cek) => {\n    const padding = resolvePadding(alg);\n    const oaepHash = resolveOaepHash(alg);\n    const keyObject = ensureKeyObject(key, alg, 'wrapKey', 'encrypt');\n    checkKey(keyObject, alg);\n    return publicEncrypt({ key: keyObject, oaepHash, padding }, cek);\n};\nexport const decrypt = (alg, key, encryptedKey) => {\n    const padding = resolvePadding(alg);\n    const oaepHash = resolveOaepHash(alg);\n    const keyObject = ensureKeyObject(key, alg, 'unwrapKey', 'decrypt');\n    checkKey(keyObject, alg);\n    return privateDecrypt({ key: keyObject, oaepHash, padding }, encryptedKey);\n};\n", "export const weakMap = new WeakMap();\nconst getLength = (buf, index) => {\n    let len = buf.readUInt8(1);\n    if ((len & 0x80) === 0) {\n        if (index === 0) {\n            return len;\n        }\n        return getLength(buf.subarray(2 + len), index - 1);\n    }\n    const num = len & 0x7f;\n    len = 0;\n    for (let i = 0; i < num; i++) {\n        len <<= 8;\n        const j = buf.readUInt8(2 + i);\n        len |= j;\n    }\n    if (index === 0) {\n        return len;\n    }\n    return getLength(buf.subarray(2 + len), index - 1);\n};\nconst getLengthOfSeqIndex = (sequence, index) => {\n    const len = sequence.readUInt8(1);\n    if ((len & 0x80) === 0) {\n        return getLength(sequence.subarray(2), index);\n    }\n    const num = len & 0x7f;\n    return getLength(sequence.subarray(2 + num), index);\n};\nconst getModulusLength = (key) => {\n    var _a, _b;\n    if (weakMap.has(key)) {\n        return weakMap.get(key);\n    }\n    const modulusLength = (_b = (_a = key.asymmetricKeyDetails) === null || _a === void 0 ? void 0 : _a.modulusLength) !== null && _b !== void 0 ? _b : (getLengthOfSeqIndex(key.export({ format: 'der', type: 'pkcs1' }), key.type === 'private' ? 1 : 0) -\n        1) <<\n        3;\n    weakMap.set(key, modulusLength);\n    return modulusLength;\n};\nexport const setModulusLength = (keyObject, modulusLength) => {\n    weakMap.set(keyObject, modulusLength);\n};\nexport default (key, alg) => {\n    if (getModulusLength(key) < 2048) {\n        throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);\n    }\n};\n", "import { createPrivateKey, createPublicKey, KeyObject } from 'crypto';\nimport { Buffer } from 'buffer';\nimport { isCryptoKey } from './webcrypto.js';\nimport isKeyObject from './is_key_object.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport { types } from './is_key_like.js';\nconst genericExport = (keyType, keyFormat, key) => {\n    let keyObject;\n    if (isCryptoKey(key)) {\n        if (!key.extractable) {\n            throw new TypeError('CryptoKey is not extractable');\n        }\n        keyObject = KeyObject.from(key);\n    }\n    else if (isKeyObject(key)) {\n        keyObject = key;\n    }\n    else {\n        throw new TypeError(invalidKeyInput(key, ...types));\n    }\n    if (keyObject.type !== keyType) {\n        throw new TypeError(`key is not a ${keyType} key`);\n    }\n    return keyObject.export({ format: 'pem', type: keyFormat });\n};\nexport const toSPKI = (key) => {\n    return genericExport('public', 'spki', key);\n};\nexport const toPKCS8 = (key) => {\n    return genericExport('private', 'pkcs8', key);\n};\nexport const fromPKCS8 = (pem) => createPrivateKey({\n    key: Buffer.from(pem.replace(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\\s)/g, ''), 'base64'),\n    type: 'pkcs8',\n    format: 'der',\n});\nexport const fromSPKI = (pem) => createPublicKey({\n    key: Buffer.from(pem.replace(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\\s)/g, ''), 'base64'),\n    type: 'spki',\n    format: 'der',\n});\nexport const fromX509 = (pem) => createPublicKey({\n    key: pem,\n    type: 'spki',\n    format: 'pem',\n});\n", "import { Buffer } from 'buffer';\nimport { createPrivateKey, createPublicKey, createSecretKey } from 'crypto';\nimport { decode as base64url } from './base64url.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport { setCurve } from './get_named_curve.js';\nimport { setModulusLength } from './check_modulus_length.js';\nimport Asn1SequenceEncoder from './asn1_sequence_encoder.js';\nimport { jwkImport } from './flags.js';\nconst parse = (jwk) => {\n    if (jwkImport && jwk.kty !== 'oct') {\n        return jwk.d\n            ? createPrivateKey({ format: 'jwk', key: jwk })\n            : createPublicKey({ format: 'jwk', key: jwk });\n    }\n    switch (jwk.kty) {\n        case 'oct': {\n            return createSecretKey(base64url(jwk.k));\n        }\n        case 'RSA': {\n            const enc = new Asn1SequenceEncoder();\n            const isPrivate = jwk.d !== undefined;\n            const modulus = Buffer.from(jwk.n, 'base64');\n            const exponent = Buffer.from(jwk.e, 'base64');\n            if (isPrivate) {\n                enc.zero();\n                enc.unsignedInteger(modulus);\n                enc.unsignedInteger(exponent);\n                enc.unsignedInteger(Buffer.from(jwk.d, 'base64'));\n                enc.unsignedInteger(Buffer.from(jwk.p, 'base64'));\n                enc.unsignedInteger(Buffer.from(jwk.q, 'base64'));\n                enc.unsignedInteger(Buffer.from(jwk.dp, 'base64'));\n                enc.unsignedInteger(Buffer.from(jwk.dq, 'base64'));\n                enc.unsignedInteger(Buffer.from(jwk.qi, 'base64'));\n            }\n            else {\n                enc.unsignedInteger(modulus);\n                enc.unsignedInteger(exponent);\n            }\n            const der = enc.end();\n            const createInput = {\n                key: der,\n                format: 'der',\n                type: 'pkcs1',\n            };\n            const keyObject = isPrivate ? createPrivateKey(createInput) : createPublicKey(createInput);\n            setModulusLength(keyObject, modulus.length << 3);\n            return keyObject;\n        }\n        case 'EC': {\n            const enc = new Asn1SequenceEncoder();\n            const isPrivate = jwk.d !== undefined;\n            const pub = Buffer.concat([\n                Buffer.alloc(1, 4),\n                Buffer.from(jwk.x, 'base64'),\n                Buffer.from(jwk.y, 'base64'),\n            ]);\n            if (isPrivate) {\n                enc.zero();\n                const enc$1 = new Asn1SequenceEncoder();\n                enc$1.oidFor('ecPublicKey');\n                enc$1.oidFor(jwk.crv);\n                enc.add(enc$1.end());\n                const enc$2 = new Asn1SequenceEncoder();\n                enc$2.one();\n                enc$2.octStr(Buffer.from(jwk.d, 'base64'));\n                const enc$3 = new Asn1SequenceEncoder();\n                enc$3.bitStr(pub);\n                const f2 = enc$3.end(Buffer.from([0xa1]));\n                enc$2.add(f2);\n                const f = enc$2.end();\n                const enc$4 = new Asn1SequenceEncoder();\n                enc$4.add(f);\n                const f3 = enc$4.end(Buffer.from([0x04]));\n                enc.add(f3);\n                const der = enc.end();\n                const keyObject = createPrivateKey({ key: der, format: 'der', type: 'pkcs8' });\n                setCurve(keyObject, jwk.crv);\n                return keyObject;\n            }\n            const enc$1 = new Asn1SequenceEncoder();\n            enc$1.oidFor('ecPublicKey');\n            enc$1.oidFor(jwk.crv);\n            enc.add(enc$1.end());\n            enc.bitStr(pub);\n            const der = enc.end();\n            const keyObject = createPublicKey({ key: der, format: 'der', type: 'spki' });\n            setCurve(keyObject, jwk.crv);\n            return keyObject;\n        }\n        case 'OKP': {\n            const enc = new Asn1SequenceEncoder();\n            const isPrivate = jwk.d !== undefined;\n            if (isPrivate) {\n                enc.zero();\n                const enc$1 = new Asn1SequenceEncoder();\n                enc$1.oidFor(jwk.crv);\n                enc.add(enc$1.end());\n                const enc$2 = new Asn1SequenceEncoder();\n                enc$2.octStr(Buffer.from(jwk.d, 'base64'));\n                const f = enc$2.end(Buffer.from([0x04]));\n                enc.add(f);\n                const der = enc.end();\n                return createPrivateKey({ key: der, format: 'der', type: 'pkcs8' });\n            }\n            const enc$1 = new Asn1SequenceEncoder();\n            enc$1.oidFor(jwk.crv);\n            enc.add(enc$1.end());\n            enc.bitStr(Buffer.from(jwk.x, 'base64'));\n            const der = enc.end();\n            return createPublicKey({ key: der, format: 'der', type: 'spki' });\n        }\n        default:\n            throw new JOSENotSupported('Invalid or unsupported JWK \"kty\" (Key Type) Parameter value');\n    }\n};\nexport default parse;\n", "import { Buffer } from 'buffer';\nimport { JOSENotSupported } from '../util/errors.js';\nconst tagInteger = 0x02;\nconst tagBitStr = 0x03;\nconst tagOctStr = 0x04;\nconst tagSequence = 0x30;\nconst bZero = Buffer.from([0x00]);\nconst bTagInteger = Buffer.from([tagInteger]);\nconst bTagBitStr = Buffer.from([tagBitStr]);\nconst bTagSequence = Buffer.from([tagSequence]);\nconst bTagOctStr = Buffer.from([tagOctStr]);\nconst encodeLength = (len) => {\n    if (len < 128)\n        return Buffer.from([len]);\n    const buffer = Buffer.alloc(5);\n    buffer.writeUInt32BE(len, 1);\n    let offset = 1;\n    while (buffer[offset] === 0)\n        offset++;\n    buffer[offset - 1] = 0x80 | (5 - offset);\n    return buffer.slice(offset - 1);\n};\nconst oids = new Map([\n    ['P-256', Buffer.from('06 08 2A 86 48 CE 3D 03 01 07'.replace(/ /g, ''), 'hex')],\n    ['secp256k1', Buffer.from('06 05 2B 81 04 00 0A'.replace(/ /g, ''), 'hex')],\n    ['P-384', Buffer.from('06 05 2B 81 04 00 22'.replace(/ /g, ''), 'hex')],\n    ['P-521', Buffer.from('06 05 2B 81 04 00 23'.replace(/ /g, ''), 'hex')],\n    ['ecPublicKey', Buffer.from('06 07 2A 86 48 CE 3D 02 01'.replace(/ /g, ''), 'hex')],\n    ['X25519', Buffer.from('06 03 2B 65 6E'.replace(/ /g, ''), 'hex')],\n    ['X448', Buffer.from('06 03 2B 65 6F'.replace(/ /g, ''), 'hex')],\n    ['Ed25519', Buffer.from('06 03 2B 65 70'.replace(/ /g, ''), 'hex')],\n    ['Ed448', Buffer.from('06 03 2B 65 71'.replace(/ /g, ''), 'hex')],\n]);\nexport default class DumbAsn1Encoder {\n    constructor() {\n        this.length = 0;\n        this.elements = [];\n    }\n    oidFor(oid) {\n        const bOid = oids.get(oid);\n        if (!bOid) {\n            throw new JOSENotSupported('Invalid or unsupported OID');\n        }\n        this.elements.push(bOid);\n        this.length += bOid.length;\n    }\n    zero() {\n        this.elements.push(bTagInteger, Buffer.from([0x01]), bZero);\n        this.length += 3;\n    }\n    one() {\n        this.elements.push(bTagInteger, Buffer.from([0x01]), Buffer.from([0x01]));\n        this.length += 3;\n    }\n    unsignedInteger(integer) {\n        if (integer[0] & 0x80) {\n            const len = encodeLength(integer.length + 1);\n            this.elements.push(bTagInteger, len, bZero, integer);\n            this.length += 2 + len.length + integer.length;\n        }\n        else {\n            let i = 0;\n            while (integer[i] === 0 && (integer[i + 1] & 0x80) === 0)\n                i++;\n            const len = encodeLength(integer.length - i);\n            this.elements.push(bTagInteger, encodeLength(integer.length - i), integer.slice(i));\n            this.length += 1 + len.length + integer.length - i;\n        }\n    }\n    octStr(octStr) {\n        const len = encodeLength(octStr.length);\n        this.elements.push(bTagOctStr, encodeLength(octStr.length), octStr);\n        this.length += 1 + len.length + octStr.length;\n    }\n    bitStr(bitS) {\n        const len = encodeLength(bitS.length + 1);\n        this.elements.push(bTagBitStr, encodeLength(bitS.length + 1), bZero, bitS);\n        this.length += 1 + len.length + bitS.length + 1;\n    }\n    add(seq) {\n        this.elements.push(seq);\n        this.length += seq.length;\n    }\n    end(tag = bTagSequence) {\n        const len = encodeLength(this.length);\n        return Buffer.concat([tag, len, ...this.elements], 1 + len.length + this.length);\n    }\n}\n", "const [major, minor] = process.versions.node.split('.').map((str) => parseInt(str, 10));\nexport const oneShotCallback = major >= 16 || (major === 15 && minor >= 13);\nexport const rsaPssParams = !('electron' in process.versions) && (major >= 17 || (major === 16 && minor >= 9));\nexport const jwkExport = major >= 16 || (major === 15 && minor >= 9);\nexport const jwkImport = major >= 16 || (major === 15 && minor >= 12);\n", "import { withAlg as invalidKeyInput } from './invalid_key_input.js';\nimport isKeyLike, { types } from '../runtime/is_key_like.js';\nconst symmetricTypeCheck = (alg, key) => {\n    if (key instanceof Uint8Array)\n        return;\n    if (!isKeyLike(key)) {\n        throw new TypeError(invalidKeyInput(alg, key, ...types, 'Uint8Array'));\n    }\n    if (key.type !== 'secret') {\n        throw new TypeError(`${types.join(' or ')} instances for symmetric algorithms must be of type \"secret\"`);\n    }\n};\nconst asymmetricTypeCheck = (alg, key, usage) => {\n    if (!isKeyLike(key)) {\n        throw new TypeError(invalidKeyInput(alg, key, ...types));\n    }\n    if (key.type === 'secret') {\n        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithms must not be of type \"secret\"`);\n    }\n    if (usage === 'sign' && key.type === 'public') {\n        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithm signing must be of type \"private\"`);\n    }\n    if (usage === 'decrypt' && key.type === 'public') {\n        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithm decryption must be of type \"private\"`);\n    }\n    if (key.algorithm && usage === 'verify' && key.type === 'private') {\n        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithm verifying must be of type \"public\"`);\n    }\n    if (key.algorithm && usage === 'encrypt' && key.type === 'private') {\n        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithm encryption must be of type \"public\"`);\n    }\n};\nconst checkKeyType = (alg, key, usage) => {\n    const symmetric = alg.startsWith('HS') ||\n        alg === 'dir' ||\n        alg.startsWith('PBES2') ||\n        /^A\\d{3}(?:GCM)?KW$/.test(alg);\n    if (symmetric) {\n        symmetricTypeCheck(alg, key);\n    }\n    else {\n        asymmetricTypeCheck(alg, key, usage);\n    }\n};\nexport default checkKeyType;\n", "import { createCipheriv, KeyObject } from 'crypto';\nimport checkIvLength from '../lib/check_iv_length.js';\nimport checkCekLength from './check_cek_length.js';\nimport { concat } from '../lib/buffer_utils.js';\nimport cbcTag from './cbc_tag.js';\nimport { isCryptoKey } from './webcrypto.js';\nimport { checkEncCryptoKey } from '../lib/crypto_key.js';\nimport isKeyObject from './is_key_object.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport supported from './ciphers.js';\nimport { types } from './is_key_like.js';\nfunction cbcEncrypt(enc, plaintext, cek, iv, aad) {\n    const keySize = parseInt(enc.slice(1, 4), 10);\n    if (isKeyObject(cek)) {\n        cek = cek.export();\n    }\n    const encKey = cek.subarray(keySize >> 3);\n    const macKey = cek.subarray(0, keySize >> 3);\n    const algorithm = `aes-${keySize}-cbc`;\n    if (!supported(algorithm)) {\n        throw new JOSENotSupported(`alg ${enc} is not supported by your javascript runtime`);\n    }\n    const cipher = createCipheriv(algorithm, encKey, iv);\n    const ciphertext = concat(cipher.update(plaintext), cipher.final());\n    const macSize = parseInt(enc.slice(-3), 10);\n    const tag = cbcTag(aad, iv, ciphertext, macSize, macKey, keySize);\n    return { ciphertext, tag };\n}\nfunction gcmEncrypt(enc, plaintext, cek, iv, aad) {\n    const keySize = parseInt(enc.slice(1, 4), 10);\n    const algorithm = `aes-${keySize}-gcm`;\n    if (!supported(algorithm)) {\n        throw new JOSENotSupported(`alg ${enc} is not supported by your javascript runtime`);\n    }\n    const cipher = createCipheriv(algorithm, cek, iv, { authTagLength: 16 });\n    if (aad.byteLength) {\n        cipher.setAAD(aad, { plaintextLength: plaintext.length });\n    }\n    const ciphertext = cipher.update(plaintext);\n    cipher.final();\n    const tag = cipher.getAuthTag();\n    return { ciphertext, tag };\n}\nconst encrypt = (enc, plaintext, cek, iv, aad) => {\n    let key;\n    if (isCryptoKey(cek)) {\n        checkEncCryptoKey(cek, enc, 'encrypt');\n        key = KeyObject.from(cek);\n    }\n    else if (cek instanceof Uint8Array || isKeyObject(cek)) {\n        key = cek;\n    }\n    else {\n        throw new TypeError(invalidKeyInput(cek, ...types, 'Uint8Array'));\n    }\n    checkCekLength(enc, key);\n    checkIvLength(enc, iv);\n    switch (enc) {\n        case 'A128CBC-HS256':\n        case 'A192CBC-HS384':\n        case 'A256CBC-HS512':\n            return cbcEncrypt(enc, plaintext, key, iv, aad);\n        case 'A128GCM':\n        case 'A192GCM':\n        case 'A256GCM':\n            return gcmEncrypt(enc, plaintext, key, iv, aad);\n        default:\n            throw new JOSENotSupported('Unsupported JWE Content Encryption Algorithm');\n    }\n};\nexport default encrypt;\n", "import { JOSENotSupported } from '../util/errors.js';\nfunction validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {\n    if (joseHeader.crit !== undefined && protectedHeader.crit === undefined) {\n        throw new Err('\"crit\" (Critical) Header Parameter MUST be integrity protected');\n    }\n    if (!protectedHeader || protectedHeader.crit === undefined) {\n        return new Set();\n    }\n    if (!Array.isArray(protectedHeader.crit) ||\n        protectedHeader.crit.length === 0 ||\n        protectedHeader.crit.some((input) => typeof input !== 'string' || input.length === 0)) {\n        throw new Err('\"crit\" (Critical) Header Parameter MUST be an array of non-empty strings when present');\n    }\n    let recognized;\n    if (recognizedOption !== undefined) {\n        recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);\n    }\n    else {\n        recognized = recognizedDefault;\n    }\n    for (const parameter of protectedHeader.crit) {\n        if (!recognized.has(parameter)) {\n            throw new JOSENotSupported(`Extension Header Parameter \"${parameter}\" is not recognized`);\n        }\n        if (joseHeader[parameter] === undefined) {\n            throw new Err(`Extension Header Parameter \"${parameter}\" is missing`);\n        }\n        else if (recognized.get(parameter) && protectedHeader[parameter] === undefined) {\n            throw new Err(`Extension Header Parameter \"${parameter}\" MUST be integrity protected`);\n        }\n    }\n    return new Set(protectedHeader.crit);\n}\nexport default validateCrit;\n", "const validateAlgorithms = (option, algorithms) => {\n    if (algorithms !== undefined &&\n        (!Array.isArray(algorithms) || algorithms.some((s) => typeof s !== 'string'))) {\n        throw new TypeError(`\"${option}\" option must be an array of strings`);\n    }\n    if (!algorithms) {\n        return undefined;\n    }\n    return new Set(algorithms);\n};\nexport default validateAlgorithms;\n", "import { KeyObject, createPublicKey } from 'crypto';\nimport { encode as base64url } from './base64url.js';\nimport Asn1SequenceDecoder from './asn1_sequence_decoder.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport getNamedCurve from './get_named_curve.js';\nimport { isCryptoKey } from './webcrypto.js';\nimport isKeyObject from './is_key_object.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport { types } from './is_key_like.js';\nimport { jwkExport } from './flags.js';\nconst keyToJWK = (key) => {\n    let keyObject;\n    if (isCryptoKey(key)) {\n        if (!key.extractable) {\n            throw new TypeError('CryptoKey is not extractable');\n        }\n        keyObject = KeyObject.from(key);\n    }\n    else if (isKeyObject(key)) {\n        keyObject = key;\n    }\n    else if (key instanceof Uint8Array) {\n        return {\n            kty: 'oct',\n            k: base64url(key),\n        };\n    }\n    else {\n        throw new TypeError(invalidKeyInput(key, ...types, 'Uint8Array'));\n    }\n    if (jwkExport) {\n        if (keyObject.type !== 'secret' &&\n            !['rsa', 'ec', 'ed25519', 'x25519', 'ed448', 'x448'].includes(keyObject.asymmetricKeyType)) {\n            throw new JOSENotSupported('Unsupported key asymmetricKeyType');\n        }\n        return keyObject.export({ format: 'jwk' });\n    }\n    switch (keyObject.type) {\n        case 'secret':\n            return {\n                kty: 'oct',\n                k: base64url(keyObject.export()),\n            };\n        case 'private':\n        case 'public': {\n            switch (keyObject.asymmetricKeyType) {\n                case 'rsa': {\n                    const der = keyObject.export({ format: 'der', type: 'pkcs1' });\n                    const dec = new Asn1SequenceDecoder(der);\n                    if (keyObject.type === 'private') {\n                        dec.unsignedInteger();\n                    }\n                    const n = base64url(dec.unsignedInteger());\n                    const e = base64url(dec.unsignedInteger());\n                    let jwk;\n                    if (keyObject.type === 'private') {\n                        jwk = {\n                            d: base64url(dec.unsignedInteger()),\n                            p: base64url(dec.unsignedInteger()),\n                            q: base64url(dec.unsignedInteger()),\n                            dp: base64url(dec.unsignedInteger()),\n                            dq: base64url(dec.unsignedInteger()),\n                            qi: base64url(dec.unsignedInteger()),\n                        };\n                    }\n                    dec.end();\n                    return { kty: 'RSA', n, e, ...jwk };\n                }\n                case 'ec': {\n                    const crv = getNamedCurve(keyObject);\n                    let len;\n                    let offset;\n                    let correction;\n                    switch (crv) {\n                        case 'secp256k1':\n                            len = 64;\n                            offset = 31 + 2;\n                            correction = -1;\n                            break;\n                        case 'P-256':\n                            len = 64;\n                            offset = 34 + 2;\n                            correction = -1;\n                            break;\n                        case 'P-384':\n                            len = 96;\n                            offset = 33 + 2;\n                            correction = -3;\n                            break;\n                        case 'P-521':\n                            len = 132;\n                            offset = 33 + 2;\n                            correction = -3;\n                            break;\n                        default:\n                            throw new JOSENotSupported('Unsupported curve');\n                    }\n                    if (keyObject.type === 'public') {\n                        const der = keyObject.export({ type: 'spki', format: 'der' });\n                        return {\n                            kty: 'EC',\n                            crv,\n                            x: base64url(der.subarray(-len, -len / 2)),\n                            y: base64url(der.subarray(-len / 2)),\n                        };\n                    }\n                    const der = keyObject.export({ type: 'pkcs8', format: 'der' });\n                    if (der.length < 100) {\n                        offset += correction;\n                    }\n                    return {\n                        ...keyToJWK(createPublicKey(keyObject)),\n                        d: base64url(der.subarray(offset, offset + len / 2)),\n                    };\n                }\n                case 'ed25519':\n                case 'x25519': {\n                    const crv = getNamedCurve(keyObject);\n                    if (keyObject.type === 'public') {\n                        const der = keyObject.export({ type: 'spki', format: 'der' });\n                        return {\n                            kty: 'OKP',\n                            crv,\n                            x: base64url(der.subarray(-32)),\n                        };\n                    }\n                    const der = keyObject.export({ type: 'pkcs8', format: 'der' });\n                    return {\n                        ...keyToJWK(createPublicKey(keyObject)),\n                        d: base64url(der.subarray(-32)),\n                    };\n                }\n                case 'ed448':\n                case 'x448': {\n                    const crv = getNamedCurve(keyObject);\n                    if (keyObject.type === 'public') {\n                        const der = keyObject.export({ type: 'spki', format: 'der' });\n                        return {\n                            kty: 'OKP',\n                            crv,\n                            x: base64url(der.subarray(crv === 'Ed448' ? -57 : -56)),\n                        };\n                    }\n                    const der = keyObject.export({ type: 'pkcs8', format: 'der' });\n                    return {\n                        ...keyToJWK(createPublicKey(keyObject)),\n                        d: base64url(der.subarray(crv === 'Ed448' ? -57 : -56)),\n                    };\n                }\n                default:\n                    throw new JOSENotSupported('Unsupported key asymmetricKeyType');\n            }\n        }\n        default:\n            throw new JOSENotSupported('Unsupported key type');\n    }\n};\nexport default keyToJWK;\n", "import { encode as base64url } from '../../runtime/base64url.js';\nimport encrypt from '../../runtime/encrypt.js';\nimport { deflate } from '../../runtime/zlib.js';\nimport generateIv from '../../lib/iv.js';\nimport encryptKeyManagement from '../../lib/encrypt_key_management.js';\nimport { JOSENotSupported, JWEInvalid } from '../../util/errors.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport { encoder, decoder, concat } from '../../lib/buffer_utils.js';\nimport validateCrit from '../../lib/validate_crit.js';\nexport const unprotected = Symbol();\nexport class FlattenedEncrypt {\n    constructor(plaintext) {\n        if (!(plaintext instanceof Uint8Array)) {\n            throw new TypeError('plaintext must be an instance of Uint8Array');\n        }\n        this._plaintext = plaintext;\n    }\n    setKeyManagementParameters(parameters) {\n        if (this._keyManagementParameters) {\n            throw new TypeError('setKeyManagementParameters can only be called once');\n        }\n        this._keyManagementParameters = parameters;\n        return this;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this._protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    setSharedUnprotectedHeader(sharedUnprotectedHeader) {\n        if (this._sharedUnprotectedHeader) {\n            throw new TypeError('setSharedUnprotectedHeader can only be called once');\n        }\n        this._sharedUnprotectedHeader = sharedUnprotectedHeader;\n        return this;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this._unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        this._unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    setAdditionalAuthenticatedData(aad) {\n        this._aad = aad;\n        return this;\n    }\n    setContentEncryptionKey(cek) {\n        if (this._cek) {\n            throw new TypeError('setContentEncryptionKey can only be called once');\n        }\n        this._cek = cek;\n        return this;\n    }\n    setInitializationVector(iv) {\n        if (this._iv) {\n            throw new TypeError('setInitializationVector can only be called once');\n        }\n        this._iv = iv;\n        return this;\n    }\n    async encrypt(key, options) {\n        if (!this._protectedHeader && !this._unprotectedHeader && !this._sharedUnprotectedHeader) {\n            throw new JWEInvalid('either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()');\n        }\n        if (!isDisjoint(this._protectedHeader, this._unprotectedHeader, this._sharedUnprotectedHeader)) {\n            throw new JWEInvalid('JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint');\n        }\n        const joseHeader = {\n            ...this._protectedHeader,\n            ...this._unprotectedHeader,\n            ...this._sharedUnprotectedHeader,\n        };\n        validateCrit(JWEInvalid, new Map(), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);\n        if (joseHeader.zip !== undefined) {\n            if (!this._protectedHeader || !this._protectedHeader.zip) {\n                throw new JWEInvalid('JWE \"zip\" (Compression Algorithm) Header MUST be integrity protected');\n            }\n            if (joseHeader.zip !== 'DEF') {\n                throw new JOSENotSupported('Unsupported JWE \"zip\" (Compression Algorithm) Header Parameter value');\n            }\n        }\n        const { alg, enc } = joseHeader;\n        if (typeof alg !== 'string' || !alg) {\n            throw new JWEInvalid('JWE \"alg\" (Algorithm) Header Parameter missing or invalid');\n        }\n        if (typeof enc !== 'string' || !enc) {\n            throw new JWEInvalid('JWE \"enc\" (Encryption Algorithm) Header Parameter missing or invalid');\n        }\n        let encryptedKey;\n        if (alg === 'dir') {\n            if (this._cek) {\n                throw new TypeError('setContentEncryptionKey cannot be called when using Direct Encryption');\n            }\n        }\n        else if (alg === 'ECDH-ES') {\n            if (this._cek) {\n                throw new TypeError('setContentEncryptionKey cannot be called when using Direct Key Agreement');\n            }\n        }\n        let cek;\n        {\n            let parameters;\n            ({ cek, encryptedKey, parameters } = await encryptKeyManagement(alg, enc, key, this._cek, this._keyManagementParameters));\n            if (parameters) {\n                if (options && unprotected in options) {\n                    if (!this._unprotectedHeader) {\n                        this.setUnprotectedHeader(parameters);\n                    }\n                    else {\n                        this._unprotectedHeader = { ...this._unprotectedHeader, ...parameters };\n                    }\n                }\n                else {\n                    if (!this._protectedHeader) {\n                        this.setProtectedHeader(parameters);\n                    }\n                    else {\n                        this._protectedHeader = { ...this._protectedHeader, ...parameters };\n                    }\n                }\n            }\n        }\n        this._iv || (this._iv = generateIv(enc));\n        let additionalData;\n        let protectedHeader;\n        let aadMember;\n        if (this._protectedHeader) {\n            protectedHeader = encoder.encode(base64url(JSON.stringify(this._protectedHeader)));\n        }\n        else {\n            protectedHeader = encoder.encode('');\n        }\n        if (this._aad) {\n            aadMember = base64url(this._aad);\n            additionalData = concat(protectedHeader, encoder.encode('.'), encoder.encode(aadMember));\n        }\n        else {\n            additionalData = protectedHeader;\n        }\n        let ciphertext;\n        let tag;\n        if (joseHeader.zip === 'DEF') {\n            const deflated = await ((options === null || options === void 0 ? void 0 : options.deflateRaw) || deflate)(this._plaintext);\n            ({ ciphertext, tag } = await encrypt(enc, deflated, cek, this._iv, additionalData));\n        }\n        else {\n            ;\n            ({ ciphertext, tag } = await encrypt(enc, this._plaintext, cek, this._iv, additionalData));\n        }\n        const jwe = {\n            ciphertext: base64url(ciphertext),\n            iv: base64url(this._iv),\n            tag: base64url(tag),\n        };\n        if (encryptedKey) {\n            jwe.encrypted_key = base64url(encryptedKey);\n        }\n        if (aadMember) {\n            jwe.aad = aadMember;\n        }\n        if (this._protectedHeader) {\n            jwe.protected = decoder.decode(protectedHeader);\n        }\n        if (this._sharedUnprotectedHeader) {\n            jwe.unprotected = this._sharedUnprotectedHeader;\n        }\n        if (this._unprotectedHeader) {\n            jwe.header = this._unprotectedHeader;\n        }\n        return jwe;\n    }\n}\n", "import * as crypto from 'crypto';\nimport { promisify } from 'util';\nimport nodeDigest from './dsa_digest.js';\nimport nodeKey from './node_key.js';\nimport sign from './sign.js';\nimport getVerifyKey from './get_sign_verify_key.js';\nimport { oneShotCallback } from './flags.js';\nlet oneShotVerify;\nif (crypto.verify.length > 4 && oneShotCallback) {\n    oneShotVerify = promisify(crypto.verify);\n}\nelse {\n    oneShotVerify = crypto.verify;\n}\nconst verify = async (alg, key, signature, data) => {\n    const keyObject = getVerifyKey(alg, key, 'verify');\n    if (alg.startsWith('HS')) {\n        const expected = await sign(alg, keyObject, data);\n        const actual = signature;\n        try {\n            return crypto.timingSafeEqual(actual, expected);\n        }\n        catch {\n            return false;\n        }\n    }\n    const algorithm = nodeDigest(alg);\n    const keyInput = nodeKey(alg, keyObject);\n    try {\n        return await oneShotVerify(algorithm, data, keyInput, signature);\n    }\n    catch {\n        return false;\n    }\n};\nexport default verify;\n", "import { JOSENotSupported } from '../util/errors.js';\nexport default function dsaDigest(alg) {\n    switch (alg) {\n        case 'PS256':\n        case 'RS256':\n        case 'ES256':\n        case 'ES256K':\n            return 'sha256';\n        case 'PS384':\n        case 'RS384':\n        case 'ES384':\n            return 'sha384';\n        case 'PS512':\n        case 'RS512':\n        case 'ES512':\n            return 'sha512';\n        case 'EdDSA':\n            return undefined;\n        default:\n            throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);\n    }\n}\n", "import { constants } from 'crypto';\nimport getNamedCurve from './get_named_curve.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport checkModulusLength from './check_modulus_length.js';\nimport { rsaPssParams } from './flags.js';\nconst PSS = {\n    padding: constants.RSA_PKCS1_PSS_PADDING,\n    saltLength: constants.RSA_PSS_SALTLEN_DIGEST,\n};\nconst ecCurveAlgMap = new Map([\n    ['ES256', 'P-256'],\n    ['ES256K', 'secp256k1'],\n    ['ES384', 'P-384'],\n    ['ES512', 'P-521'],\n]);\nexport default function keyForCrypto(alg, key) {\n    switch (alg) {\n        case 'EdDSA':\n            if (!['ed25519', 'ed448'].includes(key.asymmetricKeyType)) {\n                throw new TypeError('Invalid key for this operation, its asymmetricKeyType must be ed25519 or ed448');\n            }\n            return key;\n        case 'RS256':\n        case 'RS384':\n        case 'RS512':\n            if (key.asymmetricKeyType !== 'rsa') {\n                throw new TypeError('Invalid key for this operation, its asymmetricKeyType must be rsa');\n            }\n            checkModulusLength(key, alg);\n            return key;\n        case rsaPssParams && 'PS256':\n        case rsaPssParams && 'PS384':\n        case rsaPssParams && 'PS512':\n            if (key.asymmetricKeyType === 'rsa-pss') {\n                const { hashAlgorithm, mgf1HashAlgorithm, saltLength } = key.asymmetricKeyDetails;\n                const length = parseInt(alg.slice(-3), 10);\n                if (hashAlgorithm !== undefined &&\n                    (hashAlgorithm !== `sha${length}` || mgf1HashAlgorithm !== hashAlgorithm)) {\n                    throw new TypeError(`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of \"alg\" ${alg}`);\n                }\n                if (saltLength !== undefined && saltLength > length >> 3) {\n                    throw new TypeError(`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of \"alg\" ${alg}`);\n                }\n            }\n            else if (key.asymmetricKeyType !== 'rsa') {\n                throw new TypeError('Invalid key for this operation, its asymmetricKeyType must be rsa or rsa-pss');\n            }\n            checkModulusLength(key, alg);\n            return { key, ...PSS };\n        case !rsaPssParams && 'PS256':\n        case !rsaPssParams && 'PS384':\n        case !rsaPssParams && 'PS512':\n            if (key.asymmetricKeyType !== 'rsa') {\n                throw new TypeError('Invalid key for this operation, its asymmetricKeyType must be rsa');\n            }\n            checkModulusLength(key, alg);\n            return { key, ...PSS };\n        case 'ES256':\n        case 'ES256K':\n        case 'ES384':\n        case 'ES512': {\n            if (key.asymmetricKeyType !== 'ec') {\n                throw new TypeError('Invalid key for this operation, its asymmetricKeyType must be ec');\n            }\n            const actual = getNamedCurve(key);\n            const expected = ecCurveAlgMap.get(alg);\n            if (actual !== expected) {\n                throw new TypeError(`Invalid key curve for the algorithm, its curve must be ${expected}, got ${actual}`);\n            }\n            return { dsaEncoding: 'ieee-p1363', key };\n        }\n        default:\n            throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);\n    }\n}\n", "import * as crypto from 'crypto';\nimport { promisify } from 'util';\nimport nodeDigest from './dsa_digest.js';\nimport hmacDigest from './hmac_digest.js';\nimport nodeKey from './node_key.js';\nimport getSignKey from './get_sign_verify_key.js';\nlet oneShotSign;\nif (crypto.sign.length > 3) {\n    oneShotSign = promisify(crypto.sign);\n}\nelse {\n    oneShotSign = crypto.sign;\n}\nconst sign = async (alg, key, data) => {\n    const keyObject = getSignKey(alg, key, 'sign');\n    if (alg.startsWith('HS')) {\n        const hmac = crypto.createHmac(hmacDigest(alg), keyObject);\n        hmac.update(data);\n        return hmac.digest();\n    }\n    return oneShotSign(nodeDigest(alg), data, nodeKey(alg, keyObject));\n};\nexport default sign;\n", "import { JOSENotSupported } from '../util/errors.js';\nexport default function hmacDigest(alg) {\n    switch (alg) {\n        case 'HS256':\n            return 'sha256';\n        case 'HS384':\n            return 'sha384';\n        case 'HS512':\n            return 'sha512';\n        default:\n            throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);\n    }\n}\n", "import { KeyObject, createSecretKey } from 'crypto';\nimport { isCryptoKey } from './webcrypto.js';\nimport { checkSigCryptoKey } from '../lib/crypto_key.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport { types } from './is_key_like.js';\nexport default function getSignVerifyKey(alg, key, usage) {\n    if (key instanceof Uint8Array) {\n        if (!alg.startsWith('HS')) {\n            throw new TypeError(invalidKeyInput(key, ...types));\n        }\n        return createSecretKey(key);\n    }\n    if (key instanceof KeyObject) {\n        return key;\n    }\n    if (isCryptoKey(key)) {\n        checkSigCryptoKey(key, alg, usage);\n        return KeyObject.from(key);\n    }\n    throw new TypeError(invalidKeyInput(key, ...types, 'Uint8Array'));\n}\n", "import { decode as base64url } from '../../runtime/base64url.js';\nimport verify from '../../runtime/verify.js';\nimport { JOSEAlgNotAllowed, JWSInvalid, JWSSignatureVerificationFailed } from '../../util/errors.js';\nimport { concat, encoder, decoder } from '../../lib/buffer_utils.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport isObject from '../../lib/is_object.js';\nimport checkKeyType from '../../lib/check_key_type.js';\nimport validateCrit from '../../lib/validate_crit.js';\nimport validateAlgorithms from '../../lib/validate_algorithms.js';\nexport async function flattenedVerify(jws, key, options) {\n    var _a;\n    if (!isObject(jws)) {\n        throw new JWSInvalid('Flattened JWS must be an object');\n    }\n    if (jws.protected === undefined && jws.header === undefined) {\n        throw new JWSInvalid('Flattened JWS must have either of the \"protected\" or \"header\" members');\n    }\n    if (jws.protected !== undefined && typeof jws.protected !== 'string') {\n        throw new JWSInvalid('JWS Protected Header incorrect type');\n    }\n    if (jws.payload === undefined) {\n        throw new JWSInvalid('JWS Payload missing');\n    }\n    if (typeof jws.signature !== 'string') {\n        throw new JWSInvalid('JWS Signature missing or incorrect type');\n    }\n    if (jws.header !== undefined && !isObject(jws.header)) {\n        throw new JWSInvalid('JWS Unprotected Header incorrect type');\n    }\n    let parsedProt = {};\n    if (jws.protected) {\n        try {\n            const protectedHeader = base64url(jws.protected);\n            parsedProt = JSON.parse(decoder.decode(protectedHeader));\n        }\n        catch {\n            throw new JWSInvalid('JWS Protected Header is invalid');\n        }\n    }\n    if (!isDisjoint(parsedProt, jws.header)) {\n        throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n    }\n    const joseHeader = {\n        ...parsedProt,\n        ...jws.header,\n    };\n    const extensions = validateCrit(JWSInvalid, new Map([['b64', true]]), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);\n    let b64 = true;\n    if (extensions.has('b64')) {\n        b64 = parsedProt.b64;\n        if (typeof b64 !== 'boolean') {\n            throw new JWSInvalid('The \"b64\" (base64url-encode payload) Header Parameter must be a boolean');\n        }\n    }\n    const { alg } = joseHeader;\n    if (typeof alg !== 'string' || !alg) {\n        throw new JWSInvalid('JWS \"alg\" (Algorithm) Header Parameter missing or invalid');\n    }\n    const algorithms = options && validateAlgorithms('algorithms', options.algorithms);\n    if (algorithms && !algorithms.has(alg)) {\n        throw new JOSEAlgNotAllowed('\"alg\" (Algorithm) Header Parameter not allowed');\n    }\n    if (b64) {\n        if (typeof jws.payload !== 'string') {\n            throw new JWSInvalid('JWS Payload must be a string');\n        }\n    }\n    else if (typeof jws.payload !== 'string' && !(jws.payload instanceof Uint8Array)) {\n        throw new JWSInvalid('JWS Payload must be a string or an Uint8Array instance');\n    }\n    let resolvedKey = false;\n    if (typeof key === 'function') {\n        key = await key(parsedProt, jws);\n        resolvedKey = true;\n    }\n    checkKeyType(alg, key, 'verify');\n    const data = concat(encoder.encode((_a = jws.protected) !== null && _a !== void 0 ? _a : ''), encoder.encode('.'), typeof jws.payload === 'string' ? encoder.encode(jws.payload) : jws.payload);\n    const signature = base64url(jws.signature);\n    const verified = await verify(alg, key, signature, data);\n    if (!verified) {\n        throw new JWSSignatureVerificationFailed();\n    }\n    let payload;\n    if (b64) {\n        payload = base64url(jws.payload);\n    }\n    else if (typeof jws.payload === 'string') {\n        payload = encoder.encode(jws.payload);\n    }\n    else {\n        payload = jws.payload;\n    }\n    const result = { payload };\n    if (jws.protected !== undefined) {\n        result.protectedHeader = parsedProt;\n    }\n    if (jws.header !== undefined) {\n        result.unprotectedHeader = jws.header;\n    }\n    if (resolvedKey) {\n        return { ...result, key };\n    }\n    return result;\n}\n", "import { flattenedVerify } from '../flattened/verify.js';\nimport { JWSInvalid } from '../../util/errors.js';\nimport { decoder } from '../../lib/buffer_utils.js';\nexport async function compactVerify(jws, key, options) {\n    if (jws instanceof Uint8Array) {\n        jws = decoder.decode(jws);\n    }\n    if (typeof jws !== 'string') {\n        throw new JWSInvalid('Compact JWS must be a string or Uint8Array');\n    }\n    const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split('.');\n    if (length !== 3) {\n        throw new JWSInvalid('Invalid Compact JWS');\n    }\n    const verified = await flattenedVerify({ payload, protected: protectedHeader, signature }, key, options);\n    const result = { payload: verified.payload, protectedHeader: verified.protectedHeader };\n    if (typeof key === 'function') {\n        return { ...result, key: verified.key };\n    }\n    return result;\n}\n", "export default (date) => Math.floor(date.getTime() / 1000);\n", "const minute = 60;\nconst hour = minute * 60;\nconst day = hour * 24;\nconst week = day * 7;\nconst year = day * 365.25;\nconst REGEX = /^(\\d+|\\d+\\.\\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i;\nexport default (str) => {\n    const matched = REGEX.exec(str);\n    if (!matched) {\n        throw new TypeError('Invalid time period format');\n    }\n    const value = parseFloat(matched[1]);\n    const unit = matched[2].toLowerCase();\n    switch (unit) {\n        case 'sec':\n        case 'secs':\n        case 'second':\n        case 'seconds':\n        case 's':\n            return Math.round(value);\n        case 'minute':\n        case 'minutes':\n        case 'min':\n        case 'mins':\n        case 'm':\n            return Math.round(value * minute);\n        case 'hour':\n        case 'hours':\n        case 'hr':\n        case 'hrs':\n        case 'h':\n            return Math.round(value * hour);\n        case 'day':\n        case 'days':\n        case 'd':\n            return Math.round(value * day);\n        case 'week':\n        case 'weeks':\n        case 'w':\n            return Math.round(value * week);\n        default:\n            return Math.round(value * year);\n    }\n};\n", "import { JWTClaimValidationFailed, JWTExpired, JWTInvalid } from '../util/errors.js';\nimport { decoder } from './buffer_utils.js';\nimport epoch from './epoch.js';\nimport secs from './secs.js';\nimport isObject from './is_object.js';\nconst normalizeTyp = (value) => value.toLowerCase().replace(/^application\\//, '');\nconst checkAudiencePresence = (audPayload, audOption) => {\n    if (typeof audPayload === 'string') {\n        return audOption.includes(audPayload);\n    }\n    if (Array.isArray(audPayload)) {\n        return audOption.some(Set.prototype.has.bind(new Set(audPayload)));\n    }\n    return false;\n};\nexport default (protectedHeader, encodedPayload, options = {}) => {\n    const { typ } = options;\n    if (typ &&\n        (typeof protectedHeader.typ !== 'string' ||\n            normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {\n        throw new JWTClaimValidationFailed('unexpected \"typ\" JWT header value', 'typ', 'check_failed');\n    }\n    let payload;\n    try {\n        payload = JSON.parse(decoder.decode(encodedPayload));\n    }\n    catch {\n    }\n    if (!isObject(payload)) {\n        throw new JWTInvalid('JWT Claims Set must be a top-level JSON object');\n    }\n    const { requiredClaims = [], issuer, subject, audience, maxTokenAge } = options;\n    if (maxTokenAge !== undefined)\n        requiredClaims.push('iat');\n    if (audience !== undefined)\n        requiredClaims.push('aud');\n    if (subject !== undefined)\n        requiredClaims.push('sub');\n    if (issuer !== undefined)\n        requiredClaims.push('iss');\n    for (const claim of new Set(requiredClaims.reverse())) {\n        if (!(claim in payload)) {\n            throw new JWTClaimValidationFailed(`missing required \"${claim}\" claim`, claim, 'missing');\n        }\n    }\n    if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {\n        throw new JWTClaimValidationFailed('unexpected \"iss\" claim value', 'iss', 'check_failed');\n    }\n    if (subject && payload.sub !== subject) {\n        throw new JWTClaimValidationFailed('unexpected \"sub\" claim value', 'sub', 'check_failed');\n    }\n    if (audience &&\n        !checkAudiencePresence(payload.aud, typeof audience === 'string' ? [audience] : audience)) {\n        throw new JWTClaimValidationFailed('unexpected \"aud\" claim value', 'aud', 'check_failed');\n    }\n    let tolerance;\n    switch (typeof options.clockTolerance) {\n        case 'string':\n            tolerance = secs(options.clockTolerance);\n            break;\n        case 'number':\n            tolerance = options.clockTolerance;\n            break;\n        case 'undefined':\n            tolerance = 0;\n            break;\n        default:\n            throw new TypeError('Invalid clockTolerance option type');\n    }\n    const { currentDate } = options;\n    const now = epoch(currentDate || new Date());\n    if ((payload.iat !== undefined || maxTokenAge) && typeof payload.iat !== 'number') {\n        throw new JWTClaimValidationFailed('\"iat\" claim must be a number', 'iat', 'invalid');\n    }\n    if (payload.nbf !== undefined) {\n        if (typeof payload.nbf !== 'number') {\n            throw new JWTClaimValidationFailed('\"nbf\" claim must be a number', 'nbf', 'invalid');\n        }\n        if (payload.nbf > now + tolerance) {\n            throw new JWTClaimValidationFailed('\"nbf\" claim timestamp check failed', 'nbf', 'check_failed');\n        }\n    }\n    if (payload.exp !== undefined) {\n        if (typeof payload.exp !== 'number') {\n            throw new JWTClaimValidationFailed('\"exp\" claim must be a number', 'exp', 'invalid');\n        }\n        if (payload.exp <= now - tolerance) {\n            throw new JWTExpired('\"exp\" claim timestamp check failed', 'exp', 'check_failed');\n        }\n    }\n    if (maxTokenAge) {\n        const age = now - payload.iat;\n        const max = typeof maxTokenAge === 'number' ? maxTokenAge : secs(maxTokenAge);\n        if (age - tolerance > max) {\n            throw new JWTExpired('\"iat\" claim timestamp check failed (too far in the past)', 'iat', 'check_failed');\n        }\n        if (age < 0 - tolerance) {\n            throw new JWTClaimValidationFailed('\"iat\" claim timestamp check failed (it should be in the past)', 'iat', 'check_failed');\n        }\n    }\n    return payload;\n};\n", "import { compactVerify } from '../jws/compact/verify.js';\nimport jwtPayload from '../lib/jwt_claims_set.js';\nimport { JWTInvalid } from '../util/errors.js';\nexport async function jwtVerify(jwt, key, options) {\n    var _a;\n    const verified = await compactVerify(jwt, key, options);\n    if (((_a = verified.protectedHeader.crit) === null || _a === void 0 ? void 0 : _a.includes('b64')) && verified.protectedHeader.b64 === false) {\n        throw new JWTInvalid('JWTs MUST NOT use unencoded payload');\n    }\n    const payload = jwtPayload(verified.protectedHeader, verified.payload, options);\n    const result = { payload, protectedHeader: verified.protectedHeader };\n    if (typeof key === 'function') {\n        return { ...result, key: verified.key };\n    }\n    return result;\n}\n", "import { encode as base64url } from '../../runtime/base64url.js';\nimport sign from '../../runtime/sign.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport { JWSInvalid } from '../../util/errors.js';\nimport { encoder, decoder, concat } from '../../lib/buffer_utils.js';\nimport checkKeyType from '../../lib/check_key_type.js';\nimport validateCrit from '../../lib/validate_crit.js';\nexport class FlattenedSign {\n    constructor(payload) {\n        if (!(payload instanceof Uint8Array)) {\n            throw new TypeError('payload must be an instance of Uint8Array');\n        }\n        this._payload = payload;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this._protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this._unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        this._unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    async sign(key, options) {\n        if (!this._protectedHeader && !this._unprotectedHeader) {\n            throw new JWSInvalid('either setProtectedHeader or setUnprotectedHeader must be called before #sign()');\n        }\n        if (!isDisjoint(this._protectedHeader, this._unprotectedHeader)) {\n            throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n        }\n        const joseHeader = {\n            ...this._protectedHeader,\n            ...this._unprotectedHeader,\n        };\n        const extensions = validateCrit(JWSInvalid, new Map([['b64', true]]), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);\n        let b64 = true;\n        if (extensions.has('b64')) {\n            b64 = this._protectedHeader.b64;\n            if (typeof b64 !== 'boolean') {\n                throw new JWSInvalid('The \"b64\" (base64url-encode payload) Header Parameter must be a boolean');\n            }\n        }\n        const { alg } = joseHeader;\n        if (typeof alg !== 'string' || !alg) {\n            throw new JWSInvalid('JWS \"alg\" (Algorithm) Header Parameter missing or invalid');\n        }\n        checkKeyType(alg, key, 'sign');\n        let payload = this._payload;\n        if (b64) {\n            payload = encoder.encode(base64url(payload));\n        }\n        let protectedHeader;\n        if (this._protectedHeader) {\n            protectedHeader = encoder.encode(base64url(JSON.stringify(this._protectedHeader)));\n        }\n        else {\n            protectedHeader = encoder.encode('');\n        }\n        const data = concat(protectedHeader, encoder.encode('.'), payload);\n        const signature = await sign(alg, key, data);\n        const jws = {\n            signature: base64url(signature),\n            payload: '',\n        };\n        if (b64) {\n            jws.payload = decoder.decode(payload);\n        }\n        if (this._unprotectedHeader) {\n            jws.header = this._unprotectedHeader;\n        }\n        if (this._protectedHeader) {\n            jws.protected = decoder.decode(protectedHeader);\n        }\n        return jws;\n    }\n}\n", "import { FlattenedSign } from '../flattened/sign.js';\nexport class CompactSign {\n    constructor(payload) {\n        this._flattened = new FlattenedSign(payload);\n    }\n    setProtectedHeader(protectedHeader) {\n        this._flattened.setProtectedHeader(protectedHeader);\n        return this;\n    }\n    async sign(key, options) {\n        const jws = await this._flattened.sign(key, options);\n        if (jws.payload === undefined) {\n            throw new TypeError('use the flattened module for creating JWS with b64: false');\n        }\n        return `${jws.protected}.${jws.payload}.${jws.signature}`;\n    }\n}\n", "import epoch from '../lib/epoch.js';\nimport isObject from '../lib/is_object.js';\nimport secs from '../lib/secs.js';\nexport class ProduceJWT {\n    constructor(payload) {\n        if (!isObject(payload)) {\n            throw new TypeError('JWT Claims Set MUST be an object');\n        }\n        this._payload = payload;\n    }\n    setIssuer(issuer) {\n        this._payload = { ...this._payload, iss: issuer };\n        return this;\n    }\n    setSubject(subject) {\n        this._payload = { ...this._payload, sub: subject };\n        return this;\n    }\n    setAudience(audience) {\n        this._payload = { ...this._payload, aud: audience };\n        return this;\n    }\n    setJti(jwtId) {\n        this._payload = { ...this._payload, jti: jwtId };\n        return this;\n    }\n    setNotBefore(input) {\n        if (typeof input === 'number') {\n            this._payload = { ...this._payload, nbf: input };\n        }\n        else {\n            this._payload = { ...this._payload, nbf: epoch(new Date()) + secs(input) };\n        }\n        return this;\n    }\n    setExpirationTime(input) {\n        if (typeof input === 'number') {\n            this._payload = { ...this._payload, exp: input };\n        }\n        else {\n            this._payload = { ...this._payload, exp: epoch(new Date()) + secs(input) };\n        }\n        return this;\n    }\n    setIssuedAt(input) {\n        if (typeof input === 'undefined') {\n            this._payload = { ...this._payload, iat: epoch(new Date()) };\n        }\n        else {\n            this._payload = { ...this._payload, iat: input };\n        }\n        return this;\n    }\n}\n", "import { CompactSign } from '../jws/compact/sign.js';\nimport { JWTInvalid } from '../util/errors.js';\nimport { encoder } from '../lib/buffer_utils.js';\nimport { ProduceJWT } from './produce.js';\nexport class SignJWT extends ProduceJWT {\n    setProtectedHeader(protectedHeader) {\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    async sign(key, options) {\n        var _a;\n        const sig = new CompactSign(encoder.encode(JSON.stringify(this._payload)));\n        sig.setProtectedHeader(this._protectedHeader);\n        if (Array.isArray((_a = this._protectedHeader) === null || _a === void 0 ? void 0 : _a.crit) &&\n            this._protectedHeader.crit.includes('b64') &&\n            this._protectedHeader.b64 === false) {\n            throw new JWTInvalid('JWTs MUST NOT use unencoded payload');\n        }\n        return sig.sign(key, options);\n    }\n}\n", "import * as http from 'http';\nimport * as https from 'https';\nimport { once } from 'events';\nimport { JOSEError, JWKSTimeout } from '../util/errors.js';\nimport { concat, decoder } from '../lib/buffer_utils.js';\nconst fetchJwks = async (url, timeout, options) => {\n    let get;\n    switch (url.protocol) {\n        case 'https:':\n            get = https.get;\n            break;\n        case 'http:':\n            get = http.get;\n            break;\n        default:\n            throw new TypeError('Unsupported URL protocol.');\n    }\n    const { agent, headers } = options;\n    const req = get(url.href, {\n        agent,\n        timeout,\n        headers,\n    });\n    const [response] = (await Promise.race([once(req, 'response'), once(req, 'timeout')]));\n    if (!response) {\n        req.destroy();\n        throw new JWKSTimeout();\n    }\n    if (response.statusCode !== 200) {\n        throw new JOSEError('Expected 200 OK from the JSON Web Key Set HTTP response');\n    }\n    const parts = [];\n    for await (const part of response) {\n        parts.push(part);\n    }\n    try {\n        return JSON.parse(decoder.decode(concat(...parts)));\n    }\n    catch {\n        throw new JOSEError('Failed to parse the JSON Web Key Set HTTP response as JSON');\n    }\n};\nexport default fetchJwks;\n", "import { createSecretKey, generateKeyPair as generateKeyPairCb } from 'crypto';\nimport { promisify } from 'util';\nimport random from './random.js';\nimport { setModulusLength } from './check_modulus_length.js';\nimport { JOSENotSupported } from '../util/errors.js';\nconst generate = promisify(generateKeyPairCb);\nexport async function generateSecret(alg, options) {\n    let length;\n    switch (alg) {\n        case 'HS256':\n        case 'HS384':\n        case 'HS512':\n        case 'A128CBC-HS256':\n        case 'A192CBC-HS384':\n        case 'A256CBC-HS512':\n            length = parseInt(alg.slice(-3), 10);\n            break;\n        case 'A128KW':\n        case 'A192KW':\n        case 'A256KW':\n        case 'A128GCMKW':\n        case 'A192GCMKW':\n        case 'A256GCMKW':\n        case 'A128GCM':\n        case 'A192GCM':\n        case 'A256GCM':\n            length = parseInt(alg.slice(1, 4), 10);\n            break;\n        default:\n            throw new JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n    }\n    return createSecretKey(random(new Uint8Array(length >> 3)));\n}\nexport async function generateKeyPair(alg, options) {\n    var _a, _b;\n    switch (alg) {\n        case 'RS256':\n        case 'RS384':\n        case 'RS512':\n        case 'PS256':\n        case 'PS384':\n        case 'PS512':\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512':\n        case 'RSA1_5': {\n            const modulusLength = (_a = options === null || options === void 0 ? void 0 : options.modulusLength) !== null && _a !== void 0 ? _a : 2048;\n            if (typeof modulusLength !== 'number' || modulusLength < 2048) {\n                throw new JOSENotSupported('Invalid or unsupported modulusLength option provided, 2048 bits or larger keys must be used');\n            }\n            const keypair = await generate('rsa', {\n                modulusLength,\n                publicExponent: 0x10001,\n            });\n            setModulusLength(keypair.privateKey, modulusLength);\n            setModulusLength(keypair.publicKey, modulusLength);\n            return keypair;\n        }\n        case 'ES256':\n            return generate('ec', { namedCurve: 'P-256' });\n        case 'ES256K':\n            return generate('ec', { namedCurve: 'secp256k1' });\n        case 'ES384':\n            return generate('ec', { namedCurve: 'P-384' });\n        case 'ES512':\n            return generate('ec', { namedCurve: 'P-521' });\n        case 'EdDSA': {\n            switch (options === null || options === void 0 ? void 0 : options.crv) {\n                case undefined:\n                case 'Ed25519':\n                    return generate('ed25519');\n                case 'Ed448':\n                    return generate('ed448');\n                default:\n                    throw new JOSENotSupported('Invalid or unsupported crv option provided, supported values are Ed25519 and Ed448');\n            }\n        }\n        case 'ECDH-ES':\n        case 'ECDH-ES+A128KW':\n        case 'ECDH-ES+A192KW':\n        case 'ECDH-ES+A256KW':\n            const crv = (_b = options === null || options === void 0 ? void 0 : options.crv) !== null && _b !== void 0 ? _b : 'P-256';\n            switch (crv) {\n                case undefined:\n                case 'P-256':\n                case 'P-384':\n                case 'P-521':\n                    return generate('ec', { namedCurve: crv });\n                case 'X25519':\n                    return generate('x25519');\n                case 'X448':\n                    return generate('x448');\n                default:\n                    throw new JOSENotSupported('Invalid or unsupported crv option provided, supported values are P-256, P-384, P-521, X25519, and X448');\n            }\n        default:\n            throw new JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
